[{"categories":["技术"],"content":"概述 hasura-go-client 的文档中关于mutation部分的描述\n For example, to make the following GraphQL mutation:\n mutation($ep: Episode!, $review: ReviewInput!) { createReview(episode: $ep, review: $review) { stars commentary } } variables { \u0026quot;ep\u0026quot;: \u0026quot;JEDI\u0026quot;, \u0026quot;review\u0026quot;: { \u0026quot;stars\u0026quot;: 5, \u0026quot;commentary\u0026quot;: \u0026quot;This is a great movie!\u0026quot; } }  You can define:\n var m struct { CreateReview struct { Stars graphql.Int Commentary graphql.String } `graphql:\u0026quot;createReview(episode: $ep, review: $review)\u0026quot;` } variables := map[string]interface{}{ \u0026quot;ep\u0026quot;: starwars.Episode(\u0026quot;JEDI\u0026quot;), \u0026quot;review\u0026quot;: starwars.ReviewInput{ Stars: graphql.Int(5), Commentary: graphql.String(\u0026quot;This is a great movie!\u0026quot;), }, } 当前的版本v0.2.0似乎有出入 如果模仿这里例子编写代码，并不能得到预期的效果。\n大致上有两个问题：\n 传入的struct名称应该是一个以input结尾的类型 内部的变量必须大写首字母，又必须使用json的说明在转换的时候变成小写  正确的做法 首先在hasura 的服务器上创建数据实体，如果创建的实体名为\u0026quot;data\u0026quot;，hasura 服务器就会生成一些mutation的操作。 如果是插入一条数据，则需要调用\u0026quot;data_instert_one\u0026quot;的mutation。\ngraphql的对应操作为：\nmutation m($data: data_insert_input!) { insert_telegram_one(object: $data) { id } } { \u0026#34;data\u0026#34;: { \u0026#34;text\u0026#34;: \u0026#34;DDDEEDDSS\u0026#34; } } 这里的例子是插入列名为\u0026quot;text\u0026quot;的数据，返回自动生成的id\n对应的go程序应该是\ntype data_insert_input struct { Text graphql.String `json:\u0026#34;text\u0026#34;` } client := graphql.NewClient(url, nil) var mutation struct { InsertTelegramOne struct { Id graphql.ID } `graphql:\u0026#34;insert_data_one(object: $data)\u0026#34;` } variables := map[string]interface{}{ \u0026#34;data\u0026#34;: data_insert_input{ Text: graphql.String(text), }, } 这里注意，调用的mutation的名字是\u0026quot;insert_data_one\u0026quot;, 参数固定为\u0026quot;data_insert_input\u0026quot;都是固定的。 结构内部的变量名必须首字母大小，但必须在json转换的时候注解回小写名称（数据库中列名为小写） 在variables中定义的名称\u0026quot;data\u0026quot;,则是对应调用中\u0026quot;$data\u0026quot;\n","date":"2021-07-12","permalink":"https://windyboy.github.io/zh-cn/posts/tech/write_native_graphql_client_mutation/","series":null,"tags":["hasura","golang","graphql"],"title":"使用go的graphql本地客户端mutation"},{"categories":["技术"],"content":"概述 urfavecli 的使用文档中关于从外部资源文件读取参数的说明比较模糊，从github 的issues中也看到用户提到这个问题并提了PR，但现在这个版本依然没有更新，其实只是需要更新一下文档。\n问题  There is a separate package altsrc that adds support for getting flag values from other file input sources.\nCurrently supported input source formats:\nYAML JSON TOML\nIn order to get values for a flag from an alternate input source the following code would be added to wrap an existing cli.Flag like below:\naltsrc.NewIntFlag(\u0026amp;cli.IntFlag{Name: \u0026ldquo;test\u0026rdquo;})\nInitialization must also occur for these flags. Below is an example initializing getting data from a yaml file below.\ncommand.Before = altsrc.InitInputSourceWithContext(command.Flags, NewYamlSourceFromFlagFunc(\u0026ldquo;load\u0026rdquo;))\nThe code above will use the \u0026ldquo;load\u0026rdquo; string as a flag name to get the file name of a yaml file from the cli.Context. It will then use that file name to initialize the yaml input source for any flags that are defined on that command. As a note the \u0026ldquo;load\u0026rdquo; flag used would also have to be defined on the command flags in order for this code snippet to work.\nCurrently only YAML, JSON, and TOML files are supported but developers can add support for other input sources by implementing the altsrc.InputSourceContext for their given sources.\nHere is a more complete sample of a command using YAML support:\n package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/urfave/cli/v2\u0026#34; \u0026#34;github.com/urfave/cli/v2/altsrc\u0026#34; ) func main() { flags := []cli.Flag{ altsrc.NewIntFlag(\u0026amp;cli.IntFlag{Name: \u0026#34;test\u0026#34;}), \u0026amp;cli.StringFlag{Name: \u0026#34;load\u0026#34;}, } app := \u0026amp;cli.App{ Action: func(c *cli.Context) error { fmt.Println(\u0026#34;--test value.*default: 0\u0026#34;) return nil }, Before: altsrc.InitInputSourceWithContext(flags, altsrc.NewYamlSourceFromFlagFunc(\u0026#34;load\u0026#34;)), Flags: flags, } app.Run(os.Args) } 这段代码的意思实际做了3件事实现读取配置文件。\n 创建一个load的字符串参数，用于传递文件名的参数 创建一个test的整形参数，用于保存从配置文件中读取的内容 调用altsrc的读取功能装载  由于原版文档并没有提供运行的方式，以及参数的输出，开始读完不知道发生了什么 简而言之就是使用一个名字是load的参数，传入文件名，并在文件中读取名为test的参数\n解决方法 加入运行的指令 go run main.go --load ./app.yml 从名为app.yml的文件中读取参数test\napp.yml:\n test: 123\n 在运行的Action中加入参数test的输出 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; \u0026#34;github.com/urfave/cli/v2\u0026#34; \u0026#34;github.com/urfave/cli/v2/altsrc\u0026#34; ) func main() { flags := []cli.Flag{ altsrc.NewIntFlag(\u0026amp;cli.IntFlag{Name: \u0026#34;test\u0026#34;}), \u0026amp;cli.StringFlag{Name: \u0026#34;load\u0026#34;}, } app := \u0026amp;cli.App{ Action: func(c *cli.Context) error { fmt.Println(\u0026#34;test: \u0026#34;, c.Int(\u0026#34;test\u0026#34;)) return nil }, Before: altsrc.InitInputSourceWithContext(flags, altsrc.NewYamlSourceFromFlagFunc(\u0026#34;load\u0026#34;)), Flags: flags, } app.Run(os.Args) } 原来的：\n fmt.Println(\u0026quot;\u0026ndash;test value.*default: 0\u0026quot;)\n 替换为：\n fmt.Println(\u0026ldquo;test: \u0026ldquo;, c.Int(\u0026ldquo;test\u0026rdquo;))\n 配置文件取值覆盖 因为读取配置文件是发生在参数载入之前，所以可以通过在命令行上赋值覆盖在配置文件中的取值\ngo run main.go --test 1 --load ./app.yml test: 1 参考资料  [urfave/cli] : https://github.com/urfave/cli [issue 800] : https://github.com/urfave/cli/issues/800  ","date":"2021-06-28","permalink":"https://windyboy.github.io/zh-cn/posts/tech/urfave-cli-read-config-file/","series":null,"tags":["golang","urfave-cli","cli","config"],"title":"Urfave Cli 从配置文件读取参数"},{"categories":["技术"],"content":"概述 自建的系统如果没有使用公网资源，多数都是采用自签名的方式发放证书。最大的问题几乎就是自签名的信任问题，几乎成了自建工作环境最大的痛。大家都以为把主机的证书挂载到runner上就可以解决问题，然而并不行\n问题  clone 的过程中，证书不信任 push docker 镜像， release 发布证书不信任  解决方法 clone 如果不是把clone作为一个step，可以直接使用skip_verify: true忽略验证\nclone: tags: true skip_verify: true 当然也可以使用下面挂载主机证书的方法\n证书不信任  首先把登陆drone的用户设置成admin 在drone server启动的环境变量中设置  DRONE_USER_CREATE=username:yourgitloginname,admin:true 把项目设置为信任项目  把主机的证书目录挂载到执行环境中  - name: release-publish image: plugins/docker volumes: - name: certs path: /etc/ssl/certs volumes: - name: certs host: path: /etc/ssl/certs ","date":"2020-08-28","permalink":"https://windyboy.github.io/zh-cn/posts/tech/drone-ci-x509-issue/","series":null,"tags":["drone","x509","devops"],"title":"Drone CI 解决自签名证书的信任问题"},{"categories":["技术"],"content":"概况 原来使用hugo自带的disqus插件实现用户留言，默认情况下感觉要读取的东西太多，于是打算找一个替代产品 最好是自建服务，装载要比disqus快\n选择 根据官方的指引comments ，其实可以选择的替代品不少\n Comments Alternatives   There are a few alternatives to commenting on static sites for those who do not want to use Disqus:\n Staticman  Talkyard (Open source, \u0026amp; serverless hosting) IntenseDebate  Graph Comment  Muut  Isso (Self-hosted, Python) Utterances (Open source, GitHub comments widget built on GitHub issues) Remark42 (Open source, Golang, Easy to run docker) Commento (Open Source, available as a service, local install, or docker image) Hyvor Talk (Available as a service)   有使用github isses作为载体的，但看到网上有人反映数量会爆\nIsso 倒也是自服的，但python写的，对比remark42 还是会大一些，安装也会麻烦\n这里选择的remark42 ，考虑到本身是golang 编写，这样会有比较小的体积以及较好的性能\n安装 官方的安装指引有使用docker 和二进制安装两种方案\n因为我的服务器资源有限，其实docker都是挺重的负担，这里选择直接安装二进制文件，编写服务脚本\n从release的页面 https://github.com/umputun/remark42/releases 选择一个稳定的版本，一般就是linux 64位的版本 https://github.com/umputun/remark42/releases/download/v1.6.0/remark42.linux-amd64.tar.gz\n $ wget https://github.com/umputun/remark42/releases/download/v1.6.0/remark42.linux-amd64.tar.gz $ tar xzvf remark42.linux-amd64.tar.gz $ sudo cp remark42.linux-amd64 /usr/local/bin/remark42 因为是golang 的程序，下载包只有不到8M的体积，而且没有其他依赖，在微型服务器上安装非常舒服\n配置 创建用户/资源 $ sudo useradd -r remark42 $ sudo mkdir -m 770 /var/www/remark42 $ sudo chown :remark42 /var/www/remark42 运行参数（环境变量） $ sudo mkdir /etc/remark42 $ sudo vim /etc/remark42/remark42.conf REMARK_URL=https://myblog.address SECRET=some_secret_key_phrase_1234 SITE=myblog AUTH_ANON=true EMOJI=true systemd 服务脚本 $ sudo vim /etc/systemd/system/remark42.service [Unit] Description=remark42 comment engine After=network.target [Service] User=remark42 Group=remark42 EnvironmentFile=/etc/remark42/remark42.conf WorkingDirectory=/var/www/remark42 Restart=always RestartSec=5 ExecStart=/usr/local/bin/remark42 server [Install] WantedBy=multi-user.target $ sudo systemctl daemon-reload $ sudo systemctl start remark42 $ sudo systemctl enable remark42 配置反向代理(nginx) 最好设置一个独立的子域名，比如 remark.my.blog\n$ sudo cat /etc/nginx/sites-available/remark42 server { server_name remark.windy.me; listen 443; ssl_certificate /etc/letsencrypt/live/remark.my.blog/fullchain.pem; # managed by Certbot ssl_certificate_key /etc/letsencrypt/live/remark.my.blog/privkey.pem; # managed by Certbot include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot location / { proxy_redirect off; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_pass http://127.0.0.1:8080/; } } remark42 服务启动后，在本地监听8080端口，把nginx代理到服务上\nOAuth用户认证服务 Google  打开 https://console.developers.google.com/cloud-resource-manager 创建应用 remark 点击左上角下拉菜单，选择 APIs \u0026amp; Services ， 再点击 Credentials 在 Authorized JavaScript origins -\u0026gt; URIs 中添加blog的地址和remark服务的地址 Authorized redirect URIs -\u0026gt; URIs 中填写回掉地址 https://remark.my.blog/auth/google/callback 根据页面信息填写配置文件 remark42.conf 中相应的配置信息AUTH_GOOGLE_CID，AUTH_GOOGLE_CSEC  Github  打开开发者页面 https://github.com/settings/developers 填写 Homepage URL \u0026ldquo;https://remark.my.blog\u0026rdquo; 填写 Authorization callback URL \u0026ldquo;https://remark.my.blog/auth/github/callback\u0026quot; 根据页面 Client ID, Client Secret 更新配置文件 remark42.conf: AUTH_GITHUB_CID， AUTH_GITHUB_CSEC  Twitter  打开 https://developer.twitter.com/en/apps 创建 App 填写 Website URL \u0026ldquo;https://remark.my.blog\u0026rdquo; 填写 Callback URL \u0026ldquo;https://remark.my.blog/auth/twitter/callback\u0026quot; 点击 Keys and tokens 的tab, 查看 Consumer API keys： API key，API secret key 更新配置文件 remark42.conf， 填写 AUTH_TWITTER_CID ，AUTH_TWITTER_CSEC  配置hugo的评论模版 打开主题中的模版文件 layouts/partials/comments.html 添加remark42配置\n{{- if .Site.Params.remark42SiteID }} \u0026lt;script\u0026gt; var remark_config = { host: {{ .Site.Params.remark42Url }}, site_id: {{ .Site.Params.remark42SiteID }}, components: ['embed'], url: {{ .Permalink }}, locale: {{ .Site.Language.Lang }}, max_shown_comments: 10, theme: 'dark', }; (function(c) { for(var i = 0; i \u0026lt; c.length; i++){ var d = document, s = d.createElement('script'); s.src = remark_config.host + '/web/' +c[i] +'.js'; s.defer = true; (d.head || d.body).appendChild(s); } })(remark_config.components || ['embed']); \u0026lt;/script\u0026gt; \u0026lt;div id=\u0026quot;remark42\u0026quot; \u0026gt;\u0026lt;/div\u0026gt; {{- end }} 修改hugo配置文件config.toml\n[params] remark42SiteID = \u0026quot;myblog\u0026quot; remark42Url = \u0026quot;https://remark.my.blog\u0026quot; comments = true 配置评论管理员 在评论框在底部成功出现以后，使用Oauth服务登陆评论系统，登陆成功以后可以点击评论的nickname，可以看到当前用户编号 设置用户编号为评论管理员，可以设置多个管理员，用逗号分割\n$ sudo vim /etc/remark42/remark42.conf ADMIN_SHARED_ID=github_20924f5ace2e27ff9b98801b837b8a495308d782 配置 telegram 的通知  打开 Telegram 应用 查询联系人 BotFather 和 BotFather 对话，输入 /newbot 创建机器人 根据提示信息，还需要创建一个结尾是 _bot的机器人 根据 HTTP API的token信息填写 remark42.conf 中 NOTIFY_TELEGRAM_TOKEN  $ sudo vim /etc/remark42/remark42.conf NOTIFY_TYPE=telegram NOTIFY_TELEGRAM_TOKEN=12345678:xy778Iltzsdr45tg  使用Telegram的应用，创建一个私有的Channel， 并把新创建的机器人加为Channel管理员 使用getUpdates的api获取channel的id  访问API，https://api.telegram.org/botXXX:YYYY/getUpdates 其中 XXX:YYYY 是前面生成的token 12345678:xy778Iltzsdr45tg 如果能正确返回json，检查chat.id就是需要查询的id 直接把id填写入NOTIFY_TELEGRAM_CHAN  $ sudo vim /etc/remark42/remark42.conf NOTIFY_TELEGRAM_CHAN=1055587116   全部配置完后，重启remark42的服务\nsudo systemctl restart remark42 参考资料  [hugo comments] https://gohugo.io/content-management/comments/ [remark42 official doc] https://github.com/umputun/remark42 [hugo comments with remark42] https://blog.lasall.dev/post/hugo-and-comments-with-remark42/ [get telegram channel id] https://www.reddit.com/r/Telegram/comments/8hpnje/q_how_to_get_channel_id_or_channelusername/  ","date":"2020-07-24","permalink":"https://windyboy.github.io/zh-cn/posts/tech/setup-remark42/","series":null,"tags":["hugo","comments","remark42","disqus"],"title":"使用 Remark42 实现自建用户留言"},{"categories":["技术"],"content":"概况 在开发环境中安装kind 以后，如果要部署私有仓库中的镜像，需要把自签名的根证书添加到信任列表中。 否则需要使用kind load命令手动从主机把镜像加载到容器当中，不能自动部署，略嫌麻烦。\n问题 在部署私有镜像仓库中的镜像的时候发生错误：\u0026ldquo;x509: certificate signed by unknown authority\u0026rdquo;\n解决  查看  # get container id $ docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 8c52432697b6 kindest/node:v1.18.2 \u0026quot;/usr/local/bin/entr…\u0026quot; 3 days ago Up 4 hours 127.0.0.1:39147-\u0026gt;6443/tcp kind-control-plane # attach $ docker exec -it 8c52432697b6 /bin/bash root@kind-control-plane:/# cat /etc/issue Ubuntu 19.10 \\n \\l 发现是ubuntu 19 于是问题可以解决，要么把主机中含有自签名ca的信任列表Mount到容器中，要么在容器中添加自签名ca证书即可。\n 添加ca证书  root@kind-control-plane:/# mkdir /usr/local/share/ca-certificates/company root@kind-control-plane:/# exit $ docker cp your-ca.crt 8c52432697b6:/usr/share/etc/ca-certificates/company/ $ docker exec -it 8c52432697b6 /bin/bash root@kind-control-plane:/# update-ca-certificates # verify root@kind-control-plane:/# curl https://your-private-registry 参考  How to install certificates for command line https://askubuntu.com/questions/645818/how-to-install-certificates-for-command-line  ","date":"2020-07-20","permalink":"https://windyboy.github.io/zh-cn/posts/tech/kind-add-self-signed-ca/","series":null,"tags":["kind","docker","kubernetes","k8s","selfsigned","ca","certificate","registry","x509"],"title":"Kind添加私有仓库自签名CA证书"},{"categories":["技术"],"content":"概况 使用通用的https代理访问互联网\n受限制网络 ==\u0026gt; http proxy ==\u0026gt; nghttpx server ==\u0026gt; squid ==\u0026gt; 互联网\n  服务器\n服务器上部署代理工具 nghttp2 （nghttpx server） ，缓存服务squid 安装letsencrypt 证书\n  客户端\n客户端可以不安装特别软件，直接设置proxy就可以，在服务端如果开启客户端认证，需要在客户端安装客户证书\nhttps proxy client ==\u0026gt; https 服务\n  主要工具\n https proxy 服务器 nghttp2  certbot 安装letsencrypt 证书 缓存服务器 squid  客户端证书生成工具 easyrsa  客户端证书导入导出 openssl     安装 centos 7 #cat /etc/redhat-release CentOS Linux release 7.2.1511 (Core)  基础软件(编译)  如果使用epel的源安装，首先安装epel\n# yum install epel-release # yum install openssl git-core  nghttp2 squid   使用的代理程序是nghttpx, 安装的软件包是nghttp2，nghttp2中包含nghttpx的代理服务程序\n# yum install nghttp2 squid nghttp2 也可以自编译源码来安装，epel安装的版本是1.7,通过编译可以安装1.9\n sudo yum groupinstall \u0026quot;Development Tools\u0026quot; sudo yum install libev libev-devel zlib zlib-devel openssl openssl-devel git git clone https://github.com/nghttp2/nghttp2.git cd nghttp2 autoreconf -i automake autoconf ./configure make sudo make install  默认安装位置是 /usr/local/bin\n在centos 7的环境正不能使用最新版的1.11.0-DEV，需要使用1.9.x的版本。在clone项目以后需要checkout 1.9.x的版本\ngit checkout v1.9.x\n然后再执行编译的操作,编译安装完成以后，检查一下版本\n# /usr/local/bin/nghttpx -v\ndebian 10 （ubuntu） # lsb_release -a No LSB modules are available. Distributor ID: Debian Description: Debian GNU/Linux 10 (buster) Release: 10 Codename: buster sudo apt install nghttp2 sudo apt install python-certbot-apache -t buster-backports 安装certbot 会附带安装一个apache的服务器，需要注意，如果有web的服务，需要禁止掉，申请证书的时候可以临时启动一个 编译（略）\n easyrsa   克隆easyrsa源码\n# git clone https://github.com/OpenVPN/easy-rsa.git 把easyrsa 复制到/opt/中完成安装\n# cd easy-rsa/ # cp -r easyrsa3 /opt/ 配置 证书  https 证书  服务器端证书可以使用letsencrypt 提供的免费证书。\n配置letsencrypt 证书的时候可以使用letsencrypt.sh 的脚本,可以简化配置的过程。\n使用certbot 配置\nsudo certbot certonly -d your.domain How would you like to authenticate with the ACME CA? 1: Apache Web Server plugin (apache) 2: Nginx Web Server plugin (nginx) 3: Spin up a temporary webserver (standalone) 4: Place files in webroot directory (webroot) 申请证书的时候需要在80端口开启一个web服务，如果使用之前安装的apache可以选1，同样也可以选择nginx，如果没有web服务，也可以选3，临时启动一个服务\n 客户端验证证书  自己做一个ca，自行签发客户端证书，使用easyrsa 配置客户端证书\n# cd /opt/easyrsa3 # mv vars.example vars 编辑vars文件，去掉前面的注释，编辑中主要的变量\nset_var EASYRSA_REQ_COUNTRY \u0026quot;US\u0026quot; set_var EASYRSA_REQ_PROVINCE \u0026quot;California\u0026quot; set_var EASYRSA_REQ_CITY \u0026quot;San Francisco\u0026quot; set_var EASYRSA_REQ_ORG \u0026quot;Copyleft Certificate Co\u0026quot; set_var EASYRSA_REQ_EMAIL \u0026quot;me@example.net\u0026quot; set_var EASYRSA_REQ_OU \u0026quot;My Organizational Unit\u0026quot; 生成客户端证书\n# ./easyrsa init-pki # ./easyrsa build-ca nopass # ./easyrsa gen-dh # ./easyrsa build-client-full client-me nopass 导出CA证书\n# openssl x509 -in pki/ca.crt -out ca.pem -outform PEM 导出客户端证书\n# openssl pkcs12 -export -clcerts -in pki/issued/client-me.crt -inkey pki/private/client-me.key -out client-me.p12 # openssl pkcs12 -in client-me.p12 -out client-me.pem -clcerts 客户端电脑导入ca和客户端证书\n最终生成ca.pem, client-me.pem两个证书文件，复制到客户端，并导入。 ca.pem导入为可信任的证书颁发机构，client-me.pem导入为信任证书。\n代理  创建nghttpx的配置文件  $ sudo mkdir /etc/nghttpx $ sudo touch /etc/nghttpx/nghttpx.conf  编辑配置文件 nghttpx.conf  frontend=0.0.0.0,443;tls backend=127.0.0.1,3128;no-tls #服务器证书 private-key-file=/etc/letsencrypt/live/[domain]/privkey.pem certificate-file=/etc/letsencrypt/live/[domain]/fullchain.pem #客户端验证 dh-param-file=/etc/nghttpx/dh.pem verify-client-cacert=/etc/nghttpx/ca.pem #代理 http2-proxy=yes no-via=yes no-ocsp=yes no-host-rewrite=yes add-x-forwarded-for=yes strip-incoming-x-forwarded-for=yes 其中[domain]为服务器的域名，privkey.pem, fullchain.pem是letsencrypt生成的服务器证书。dh.pem, ca.pem是客户端证书\n ngttpx服务  $ sudo vi /etc/systemd/system/nghttpx.service 编辑内容\n[Unit] Description=nghttpx After=network.target [Service] Type=simple ExecStart=/usr/local/bin/nghttpx --conf=/etc/nghttpx/nghttpx.conf ExecReload=/bin/kill -SIGUSR1 ${MAINPID} ExecStop=/bin/kill -SIGQUIT ${MAINPID} [Install] WantedBy=multi-user.target 服务\n$ sudo systemctl daemon-reload $ sudo systemctl start nghttpx $ sudo systemctl enable nghttpx 缓存 通过yum安装的squid服务，默认配置基本上已经满足要求，需要做一点小修改\n 编辑配置  $ sudo vi /etc/squid/squid.conf 在配置文件尾部加上\nvia off forwarded_for delete access_log none  重启服务  $ sudo systemctl restart squid 参考资料  nghttpx 官方指引 https://nghttp2.org/documentation/nghttpx-howto.html 谷歌上另外一篇参考的nghttpx+squid https://wzyboy.im/post/1052.html nghttpx 的配置，证书，服务脚本 https://blog.apar.jp/linux/2584/ centos 编译 nghttp2 https://gist.github.com/sonots/2bdf6cd26c23ef44db71 certbot on debian 10 https://www.tecmint.com/setup-free-ssl-certificate-for-apache-on-debian-10/ 免费证书提供 https://letsencrypt.org/ client 证书生成 https://gist.github.com/mtigas/952344  VPS引用  [linode 东京] (https://www.linode.com/?r=ec0967c3fb5243693ca573d68000d3a63442ac66) [bandwagonhost 中国优化] (https://bandwagonhost.com/aff.php?aff=20451) [cubenet] (https://www.cubecloud.net/aff.php?aff=963)  ","date":"2020-07-17","permalink":"https://windyboy.github.io/zh-cn/posts/tech/proxy-with-nghttpx-squid/","series":null,"tags":["nghttpx","squid","proxy","http2"],"title":"nghttpx搭配squid科学浏览（更新debian）"},{"categories":["技术"],"content":"概况  apache tomcat 应用服务器（在不使用apr连接器时）使用SSL证书的时候使用的是java专属的证书管理方式keystore , 并不能直接使用letsencrypt 的免费证书。 要把证书导入keystore , 首先需要使用openssl 把证书导出到.p12文件中，然后使用keytool把ca倒入为root(alias root)， 把服务器的证书导入为tomcat(alias tomcat)。  导入证书  前提  已经成功申请到有效的证书(使用letsencrypt 申请有效的服务器证书)。\n 使用 openssl 工具，把证书导出到.p12文件中   # openssl pkcs12 -export -in cert.pem -inkey privkey.pem \\ -out cert_and_key.p12 -name tomcat \\ -CAfile chain.pem -caname root Enter Export Password: Verifying - Enter Export Password: 提示输入导出密码，这里导出密码，可以直接回车，此时密码为空。 如果输入了密码，则在下面导入的时候需要输入相同的密码\n 使用keytool导入证书和ca   # keytool -importkeystore \\ -deststorepass \u0026lt;changeit\u0026gt; -destkeypass \u0026lt;changeit\u0026gt; \\ -destkeystore MyDSKeyStore.jks -srckeystore cert_and_key.p12 \\ -srcstoretype PKCS12 \\ -srcstorepass \u0026lt;theExportPasswordAbove\u0026gt; -alias tomcat 注意deststorepass和destkeypass必须相同，否则tomcat无法获取证书\n # keytool -import -trustcacerts \\ -srcstorepass \u0026lt;theExportPasswordAbove\u0026gt; \\ -alias root -file chain.pem -keystore MyKeyStore.jks  配置apache tomcat    # vim conf/server.xml \u0026lt;Connector port=\u0026quot;443\u0026quot; protocol=\u0026quot;org.apache.coyote.http11.Http11Protocol\u0026quot; maxThreads=\u0026quot;150\u0026quot; SSLEnabled=\u0026quot;true\u0026quot; scheme=\u0026quot;https\u0026quot; secure=\u0026quot;true\u0026quot; keystoreFile=\u0026quot;/\u0026lt;path\u0026gt;/MyKeyStore.jks\u0026quot; keystorePass=\u0026quot;\u0026lt;changeit\u0026gt;\u0026quot; clientAuth=\u0026quot;false\u0026quot; sslProtocol=\u0026quot;TLS\u0026quot; /\u0026gt; keystoreFile 是MyKeyStore.jks文件的绝对路径\nkeystorePass 是MyKeyStore.jks的storepasss以及keypass, 必须相同\n参考资料  How to use the certificate for Tomcat https://community.letsencrypt.org/t/how-to-use-the-certificate-for-tomcat/3677 keytool - Key and Certificate Management Tool http://docs.oracle.com/javase/6/docs/technotes/tools/windows/keytool.html Tomcat SSL/TLS Configuration HOW-TO https://tomcat.apache.org/tomcat-7.0-doc/ssl-howto.html letsencrypt.sh 证书制作 https://www.hshh.org/letsencrypt/letsencrypt.sh_http-01 免费证书提供 https://letsencrypt.org/  VPS 推荐  [linode 东京] (https://www.linode.com/?r=ec0967c3fb5243693ca573d68000d3a63442ac66) [bandwagonhost 中国优化] (https://bandwagonhost.com/aff.php?aff=20451) [dgchost 新加波] (https://www.dgchost.net/client/aff.php?aff=226)  ","date":"2016-09-28","permalink":"https://windyboy.github.io/zh-cn/posts/tech/tomcat-keystore-using-letsencrypt-certs/","series":null,"tags":["tomcat","ssl","keystore","letsencrypt"],"title":"tomcat 以 keystore 的方式使用 letsencrypt 证书"}]